package com.neverwinterdp.demandspike.worker;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.handler.codec.http.DefaultFullHttpRequest;
import io.netty.handler.codec.http.HttpMethod;

import java.io.Serializable;
import java.net.MalformedURLException;
import java.util.concurrent.CountDownLatch;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Histogram;
import com.codahale.metrics.Meter;
import com.codahale.metrics.Timer;
import com.neverwinterdp.demandspike.client.Client;
import com.neverwinterdp.demandspike.client.HttpClient;
import com.neverwinterdp.demandspike.client.HttpResponseHandler;
import com.neverwinterdp.demandspike.commandline.SpikeEnums;
import com.neverwinterdp.demandspike.job.JobConfig;

public class SpikeRunner implements Runnable, Serializable {
  private static Logger logger;
  /**
   * 
   */
  private static final long serialVersionUID = 1L;
  private String taskId;
  private DataGenerator dataGenerator;
  private final String url;
  private long failures = 0;
  private long maxFailedMessages;
  private final CountDownLatch latch;
  private final JobConfig config;

  public SpikeRunner(String taskID, JobConfig config, CountDownLatch latch) {
    logger = LoggerFactory.getLogger("DemandSpike");
    this.taskId = taskID;
    this.url = config.getTargets().get(0);
    this.config = config;
    this.latch = latch;
    this.dataGenerator = new DataGenerator(this.config);
  }

  public SpikeRunner(JobConfig config) {
    logger = LoggerFactory.getLogger("DemandSpike");
    this.url = config.getTargets().get(0);
    this.config = config;
    this.latch = new CountDownLatch(1);
    this.dataGenerator = new DataGenerator(config);
  }

  @Override
  public void run() {
    if (config.sendPeriod > 0) {
      // sendPeriod();
    } else {
      try {
        Client c = new HttpClient(url, config);
        c.start();
        sendContinuous(c);
        c.stop();
        latch.countDown();

      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (MalformedURLException e) {
        e.printStackTrace();
      }

    }
  }

  void sendContinuous(Client c) throws InterruptedException {
    boolean generateData = false;
    DefaultFullHttpRequest request;
    HttpMethod method = null;
    if (config.method.equals(SpikeEnums.METHOD.GET)) {
      method = HttpMethod.GET;
    } else if (config.method.equals(SpikeEnums.METHOD.POST)) {
      method = HttpMethod.POST;
    }

    long stopTime = System.currentTimeMillis() + config.maxDuration;
    int j;
    long roundStoptime = System.currentTimeMillis() + 1000;
    failures = 0;
    maxFailedMessages = (long) ((config.rate * config.stopOnFailure) / 100);
    generateData = isAutoGenerateData(config.data);
    final Timer.Context cxt = SpikeWorker.getTimerContext("responses");
    final Meter meter = SpikeWorker.getMeter("requests");
    final Histogram histogram = SpikeWorker.getHistogram("response-sizes");

    HttpResponseHandler responseHandler = new HttpResponseHandler();
    long time;
    responseHandler.setMeters(cxt, meter, histogram);

long i;
    for (i = 0; i < config.requestsPerThread / config.rate; i++) {

      for (j = 0; j < config.rate; j++) {
        if (config.data != null) {
          if (generateData) {
            dataGenerator.setIdPrefix(taskId);
            request = c.createRequest(method, getByteBuf(dataGenerator.next(config.data)));
          } else {
            request = c.createRequest(method, getByteBuf(config.data));
          }
        } else {
          request = c.createRequest(method, null);
        }
        request.retain(config.requestsPerThread);
        c.sendRequest(request, responseHandler);
        time = System.currentTimeMillis();
        if (time >= roundStoptime || time >= stopTime) {
          break;
        }
      }
      /*long diff = roundStoptime -System.currentTimeMillis();
      if ( diff  > 0) {
        Thread.sleep(diff);

      }*/
      failures = c.getFailures();
      c.initFailure();
      if (failures > maxFailedMessages) {
        break;
      }
      System.out.println(j + " Messages/second, failures : " + failures);
      roundStoptime = System.currentTimeMillis() + 1000;
    }

  }

  // private helper
  private ByteBuf getByteBuf(String data) {
    return Unpooled.wrappedBuffer(data.getBytes());
  }

  // private helper
  private boolean isAutoGenerateData(String data) {
    if (data != null
        && (data.contains(DataGenerator.AUTO_INCREMENT_INT_KEY) || data.contains(DataGenerator.RANDOM_STRING_KEY))) {
      return true;
    }
    return false;
  }

}
