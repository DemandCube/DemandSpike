package com.neverwinterdp.demandspike.worker;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.handler.codec.http.DefaultFullHttpRequest;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpResponse;
import io.netty.util.CharsetUtil;

import java.io.Serializable;
import java.net.MalformedURLException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.codahale.metrics.Histogram;
import com.codahale.metrics.Meter;
import com.codahale.metrics.Timer;
import com.neverwinterdp.demandspike.client.Client;
import com.neverwinterdp.demandspike.client.HttpClient;
import com.neverwinterdp.demandspike.client.ResponseHandler;
import com.neverwinterdp.demandspike.commandline.SpikeEnums;
import com.neverwinterdp.demandspike.job.JobConfig;

public class SpikeRunner implements Runnable, Serializable {
	private static Logger logger;
	/**
   * 
   */
	private static final long serialVersionUID = 1L;
	private String taskId;
	private DataGenerator dataGenerator;
	private final String url;

	private final CountDownLatch latch;
	private final JobConfig config;

	public SpikeRunner(String taskID, JobConfig config, CountDownLatch latch) {
		logger = LoggerFactory.getLogger("DemandSpike");
		this.taskId = taskID;
		this.url = config.getTargets().get(0);
		this.config = config;
		this.latch = latch;
		this.dataGenerator = new DataGenerator(this.config);
	}

	public SpikeRunner(JobConfig config) {
		logger = LoggerFactory.getLogger("DemandSpike");
		this.url = config.getTargets().get(0);
		this.config = config;
		this.latch = new CountDownLatch(1);
		this.dataGenerator = new DataGenerator(config);
	}

	@Override
	public void run() {
		if (config.sendPeriod > 0) {
			// sendPeriod();
		} else {
			try {
				final CountDownLatch localLatch = new CountDownLatch(
						config.requestsPerThread);
				Client c = null;
				try {
					c = new HttpClient(url,config);
				} catch (MalformedURLException e) {
					e.printStackTrace();
				}
				try {
					if (!c.start()) {
						return;
					}
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

				sendContinuous(c, localLatch);
				localLatch.await(2, TimeUnit.SECONDS);

				c.stop();
				latch.countDown();

			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	void sendContinuous(Client c, final CountDownLatch localLatch)throws InterruptedException {
		final AtomicInteger bufferSize = new AtomicInteger();
		final AtomicLong requestCounter = new AtomicLong();
        boolean generateData = false;
		DefaultFullHttpRequest request;
		HttpMethod method = null;
		if (config.method.equals(SpikeEnums.METHOD.GET)) {
			method = HttpMethod.GET;
		} else if (config.method.equals(SpikeEnums.METHOD.POST)) {
			method = HttpMethod.POST;
		}
		if (config.data != null) {
			request = c.createRequest(method, getByteBuf(config.data));
  			generateData = isAutoGenerateData(config.data);
		} else {
			request = c.createRequest(method, null);
		}
		dataGenerator.setIdPrefix(taskId);
	    long stopTime = System.currentTimeMillis() + config.maxDuration;
		int j = 0;
		long stop = System.currentTimeMillis() + 1000;
		long failures=0;
		long maxFailedMessages = (long) ((config.rate * config.stopOnFailure)/100);
		for (long i = 0; i < config.requestsPerThread; i++) {
			bufferSize.incrementAndGet();
			/*
			 * while (bufferSize.get() >= 30) { Thread.sleep(500); }
			 */
			if (generateData) {
        		request = c.createRequest(method, getByteBuf(dataGenerator.next(config.data)));
      		}
			final Timer.Context cxt = SpikeWorker.getTimerContext("responses");
			final Meter meter = SpikeWorker.getMeter("requests");
			final Histogram histogram = SpikeWorker
					.getHistogram("response-sizes");

			c.sendRequest(request, new ResponseHandler() {
				@Override
				public void onResponse(HttpResponse response) {
					cxt.close();
					meter.mark();
					HttpContent content = (HttpContent) response;
					histogram.update(content.content().readableBytes());
					String json = content.content().toString(CharsetUtil.UTF_8);
					if (json.trim() != "" && json != null) {
						logger.info("Response string : " + json);
					}
					// bufferSize.decrementAndGet();
          if (response.getStatus().code() >= 200 && response.getStatus().code() < 300) {
            SpikeWorker.getMetricRegistry().counter("2xx").inc();
          } else if (response.getStatus().code() >= 300 && response.getStatus().code() < 400) {
            SpikeWorker.getMetricRegistry().counter("3xx").inc();
          } else if (response.getStatus().code() >= 400 && response.getStatus().code() < 500) {
            SpikeWorker.getMetricRegistry().counter("4xx").inc();
          } else if (response.getStatus().code() >= 500 && response.getStatus().code() < 600) {
            SpikeWorker.getMetricRegistry().counter("5xx").inc();
          } else {
            SpikeWorker.getMetricRegistry().counter("others").inc();
          }
					requestCounter.incrementAndGet();

					if (requestCounter.get() >= config.requestsPerThread) {
						localLatch.countDown();
					}
				}
			});
			
			long time = System.currentTimeMillis();
			if (time >= stopTime) {
				localLatch.countDown();
				break;
			} else {
				if (j > config.rate || time >= stop) {
					failures = c.getFailures();
					if(failures > maxFailedMessages ){
						System.err.println("Failure Case, failed messages : "+failures);
						break;
					}
					System.out.println(j
							+ " Messages/second, failed messages are "
							+ failures);
					j = 0;
					c.initFailure();
					stop = System.currentTimeMillis() + 1000;

				}
			}
			j++;

		}
 	localLatch.countDown();
    Thread.sleep(1000);
	}
  // private helper
  private ByteBuf getByteBuf(String data) {
    return Unpooled.wrappedBuffer(data.getBytes());
  }
 // private helper
  private boolean isAutoGenerateData(String data) {
    if (data.contains(DataGenerator.AUTO_INCREMENT_INT_KEY)
        || data.contains(DataGenerator.RANDOM_STRING_KEY)) {
      return true;
    }
    return false;
  }

}
